# Intern-Excel-Analysisプロジェクト仕様書

## 目次
1. [プロジェクト概要](#1-プロジェクト概要)
2. [ファイル構成](#2-ファイル構成)
3. [必要なパッケージと依存関係](#3-必要なパッケージと依存関係)
4. [データ処理機能](#4-データ処理機能)
5. [チャットボット機能](#5-チャットボット機能)
6. [エージェント機能](#6-エージェント機能)
7. [テストとデバッグ](#7-テストとデバッグ)
8. [今後の展望](#8-今後の展望)

---

## 1. プロジェクト概要


本プロジェクトは、ロボットプログラミングに関連する演習を目的とした「robot-programming」プロジェクトです。主に、ROS（Robot Operating System）環境内でのロボットのシミュレーションや制御に関する機能を提供します。本プロジェクトの開発背景には、教育的な目的により、学生や研究者がロボットプログラミングの基礎を学ぶことを支援するためのニーズがあります。

### 開発の経緯

ロボット技術が急速に発展している現代において、ロボットプログラミングのスキルは非常に重要となっています。このプロジェクトは、そのようなスキルを習得したいユーザーを対象に、具体的なプログラムや演習を通じて実践的な知識を身につけることができるように設計されています。プロジェクトは、利用者のフィードバックを基に改善を続け、より実用的なシミュレーション体験を提供することを目指しています。

### 主要な機能

本プロジェクトには以下の主要な機能が含まれています：

- **ROS環境のセットアップ**：ユーザーが容易にROSをセットアップし、プロジェクトを開始できる手順を提供します。
- **シミュレーターの起動**：指定されたコマンドを使用して、ロボットのシミュレーターを簡単に立ち上げることができます。
- **カラートラッキング機能**：OpenCVを活用したカラートラッキングノードを提供し、リアルタイムでカラー情報を処理します。
- **チェッカーボードトラッキング機能**：画像処理を行い、特定のパラメータを使用してチェッカーボードを追跡する機能を提供します。
- **ドキュメントとサポート**：プロジェクトに関する詳細なマニュアルやオンラインヘルプへのリンクを提供し、ユーザーが容易に学習できるようにしています。

### ターゲットユーザー

本プロジェクトの主なターゲットユーザーは、ロボット工学を学ぶ学生、研究者、エンジニア、さらにロボットプログラミングに興味を持つ一般のユーザーです。特に、ROSに基づくロボットの開発や制御技術を学ぶためのリソースを求める学習者に対して、実際に手を動かしながら学べる環境を提供します。

## 2. ファイル構成


このセクションでは、プロジェクト内のファイルやディレクトリの構成を示し、各ファイルの役割や具体的な内容について説明します。重複を排除し、特に重要なファイルについてはその実装目的や機能を簡潔に説明します。

### ファイル一覧

#### 1. `code/code_git_excel_analysis/LangChain_2_LLM/practice.py`
- **役割**: データ分析や処理に関連する機能を実装している。
- **内容**: 
  - このファイルにはセンシティブな情報が含まれているため、具体的な関数や変数の役割、および全体の処理内容を詳細に説明することはできません。

#### 2. `code/code_cbl/RIREKI.CBL`
- **役割**: データファイルの定義とデータ構造を記述するCOBOLプログラム。
- **内容**:
  1. **ファイル定義**:
     - `SELECT` 文により、`RIREKIL` というファイルを定義。
     - インデックス付きファイルで動的アクセス可能。
     - ファイル状態を管理するための `FILE STATUS` 変数の設定。
     - 自動ロックモード。
  2. **データ構造**:
     - 主なデータ構造 (`01 儗僐乕僪`) とサブフィールドの定義。
     - 別の構造体 (`01 儗僐乕僪僨乕僞`) にも複雑なデータフィールドが含まれている。
  3. **未表示部分**:
     - 内容が非表示の行は推測せず、そのまま扱う。

#### 3. `code/code_cbl/Tikucode.cbl`
- **役割**: 特定のデータ構造の定義を行うCOBOLプログラム。
- **内容**:
  1. **ファイルヘッダーとメタデータ**:
     - システム名や言語、製品日付、目的が記載されている。
  2. **データ項目の定義**:
     - メインのデータグループ (`優僐乕僪`) とそのサブ項目の定義。
     - 複数のフィールドが含まれる。
     - 特定のデータ形式を持つ構造体としてデータを格納。

#### 4. `code/code_cbl/Choriyu.CBL`
- **役割**: データ構造の定義を行うCOBOLプログラムで、特定の条件下で処理を実行することを目的としている。
- **内容**:
  1. **ファイルヘッダー情報**:
     - メタデータや目的が記載され、ゲーム関連の用途が示唆されている。
  2. **データ定義**:
     - 主データ構造 (`01 儗僐乕僪`) とその詳細、サブグループが含まれる。
     - 各フィールドの属性（整数、文字列）の詳細が定義されている。

このように、各ファイルはそれぞれ異なる役割を持ち、関連するデータや処理に対する具体的な構造や定義が示されています。

## 3. 必要なパッケージと依存関係


このセクションでは、Pythonプロジェクトに必要なライブラリとそのバージョン、および依存関係の詳細をリストアップします。再現性を確保するために、`requirements.txt`内のバージョンを正確に記載します。

### 1. Pythonライブラリとそのバージョン

以下は、プロジェクトで使用される主要なPythonライブラリのリストです。

- `aiohttp`: 非同期HTTPクライアント/サーバーライブラリ。
- `fastapi`: 高速APIサーバーの構築を容易にするフレームワーク。
- `pandas`: データ操作のためのライブラリ。
- `scikit-learn`: 機械学習のためのライブラリ。
- `torch`: PyTorchライブラリ、深層学習に広く利用される。
- `spacy`: 自然言語処理のためのライブラリ。
- `redis`: Redisデータベースに対する操作を可能にするライブラリ。

### 2. 依存関係の詳細

各ライブラリには特定のバージョンが指定されており、これによって互換性のある環境を保証します。具体的なバージョン番号は以下の通りです。

```
aiohttp==<version>
fastapi==<version>
pandas==<version>
scikit-learn==<version>
torch==<version>
spacy==<version>
redis==<version>
```

> 注: バージョン番号は`requirements.txt`内で与えられた情報に基づいて適切に設定してください。

### 3. ROS関連の依存関係

また、ROSパッケージに関しては以下の依存関係が定義されています。

- ビルド依存関係:
  - `dynamixel_msgs`
  - `dynamixel_driver`
  - `dynamixel_controllers`
  - `pr2eus`

- 実行時依存関係:
  - 上記のビルド依存関係と同様です。

### 4. バージョンの管理

依存関係のバージョン管理は、全体の安定性を確保する上で重要です。環境を再構築する際には、以下のコマンドを使用して依存関係をインストールします。

```bash
pip install -r requirements.txt
```

これにより、指定されたバージョンのライブラリがインストールされ、プロジェクトが期待通りに動作することが可能です。

## 4. データ処理機能


本セクションでは、データ分析に関する機能、特にLangChainやPDFからのデータ抽出処理についての流れや使用方法を詳述します。これにより、実装目的が明確になります。

### LangChainを利用したデータ処理

#### 1. LangChainの概要
LangChainは、特に自然言語処理（NLP）に特化したフレームワークであり、データの分析や処理を行うための豊富な機能を提供します。このフレームワークを使用することで、モデルとデータの連携が容易になり、複雑なデータ処理タスクを効率的に実行できます。

#### 2. 主な構成要素

- **メモリ管理**: `memory.py`ファイルには、LangChainフレームワーク内でのメモリ管理機能が含まれており、各インスタンスごとに独立した記憶データを保持するためのクラスや関数が定義されています。これにより、前のデータや文脈を保持することで、より一貫したデータの取り扱いが可能となります。

- **エージェント機能**: `1_agent.py`ファイルは、情報を動的に取得し処理を行うエージェントを設定・実行します。エージェントは、指定したツールを利用し、特定のタスク（例：ウェブからのデータ取得）を自動化します。エージェントの初期化では、様々な設定（チャットモデルの温度や工具の種類）を行い、実行過程の出力も可能となります。

- **LLM処理**: `llmchain.py`ファイルは、入力テキストに基づいて出力テキストを生成または変換するためのクラスや関数が含まれています。ここでは大規模言語モデルを使用することで、データからの洞察を得たり、特定の応答を生成したりする処理を行います。

#### 3. データ抽出処理の流れ

PDFファイルからのデータ抽出についての具体的な実装は非表示ですが、一般的な流れは以下のようになります。

1. **PDFデータの取り込み**: PDFファイルを読み込み、必要なデータフォーマットに変換します。
2. **テキスト解析**: 抽出したテキストデータに対して自然言語処理を施し、データのクレンジングや前処理を行います。この段階で、無駄な情報を排除し、分析に必要なデータを整形します。
3. **メモリへの保存**: 整形されたデータをメモリに保存し、後の参照や処理のために利用できるようにします。
4. **データ分析の実行**: 様々な分析手法を用いて、抽出されたデータから洞察を得ます。これは、言語モデルによる推論や関数の利用を通じて実現されます。

### まとめ

LangChainとその関連機能は、データの抽出・分析をスムーズに行えるよう設計されており、特にNLPタスクにおいてそのパフォーマンスが発揮されます。メモリ機能、エージェント機能、LLMを駆使することで、データ処理の効率が大幅に向上し、ユーザーはより高度な情報を取得することが可能になります。

## 5. チャットボット機能


このセクションでは、チャットボット機能の実装詳細について説明します。ユーザーとの会話履歴を保持し、適切な応答を生成するための具体的な手法やアルゴリズムについて解説します。

### 5.1 概要

チャットボットは、ユーザーからのメッセージに基づいて応答を生成する能力を持つプログラムです。この実装では、LangChainライブラリとOpenAIのGPT-3.5-Turboモデルを使用して、ユーザーとの対話を記録し、その履歴に基づいてコンテキストを持つ応答を生成します。以下の点について詳細に説明します。

### 5.2 使用ライブラリ

- **Chainlit**: チャットボットのインターフェースを構築するために使用されます。
- **LangChain**: チャットの処理を行うためのツールキットであり、会話履歴の管理やモデル呼び出しに使用されます。

### 5.3 コンポーネント

#### 5.3.1 モデルと記憶の設定

1. **チャットモデル**
   - `ChatOpenAI`: GPT-3.5-Turboモデルを利用し、自然な会話を生成します。`chat = ChatOpenAI(model="gpt-3.5-turbo")` において初期化されます。

2. **メモリ**
   - `ConversationBufferMemory`: ユーザーからのメッセージやチャットのコンテキストを保持します。以下のように初期化されます。
     ```python
     memory = ConversationBufferMemory(return_messages=True)
     ```
   - これにより、過去のメッセージを参照することが可能となります。

#### 5.3.2 イベントのハンドリング

1. **チャット開始イベント**
   - `@cl.on_chat_start`: チャットが開始されるときに呼び出される関数を定義します。初期メッセージをユーザーに送信するために、`async def on_chat_start()`が使用されます。
   - 具体的なメッセージは以下の通りです。
     ```python
     await cl.Message(content="私は会話の文脈を考慮した返答ができます。メッセージを入力してください").send()
     ```

2. **メッセージ受信と処理**
   - `@cl.on_message`: 新しいメッセージを受け取る際に呼び出されるイベントハンドラを設定します。`async def on_message(message)`により、ユーザーからのメッセージを処理します。
   - メッセージの処理内容は以下の手順で行われます。
     - ユーザーからのメッセージを取得し、メモリから過去のメッセージ履歴を読み込みます。
     - 新たに受け取ったメッセージを履歴に追加し、`chat(messages)`メソッドを呼び出して応答を生成します。
     - 最後に生成された応答をユーザーに送信します。
   - 例:
     ```python
     memory_message_result = memory.load_memory_variables({})
     messages = memory_message_result["history"]
     messages.append(HumanMessage(content=message_content))
     result = chat(messages)
     await cl.Message(content=result.content).send()
     ```

#### 5.3.3 エラーハンドリング（chat_memory_3.py）

- チャット履歴の管理にRedisを使用する際、接続失敗時には代わりに`ChatMessageHistory`を利用するロジックが組まれています。
- エラーハンドリングを行い、メッセージ処理中に問題が発生した場合には適切なエラーメッセージをユーザーに返します。

#### 5.3.4 コールバックの利用（chainlit_callback.py）

- コールバックハンドラを通じて、チャットモデルが実行される際の詳細なログ情報をコンソールやファイルに記録します。これにより、モデルの振る舞いやユーザー入力を追跡することが可能になります。

### 5.4 まとめ

以上が、チャットボット機能の実装に関する詳細な説明です。このシステムは、ユーザーによるメッセージ入力を受け付け、記憶された会話の履歴に基づいて応答を生成することで、効果的なコミュニケーションを可能にしています。また、Redisを利用した履歴管理や、コールバックを介したロギング機能の実装により、操作性と追跡性も向上しています。

## 6. エージェント機能


このセクションでは、LangChainライブラリを使用して作成されたエージェント機能について詳述します。具体的には、データ取得プロセス、ユーザーからの指示への応答、および生成されたデータの扱いについて説明します。

### 1. エージェントの概要

エージェントとは、指定されたツールを利用して外部データソースから情報を取得し、その情報を基に処理を行い、ユーザーの指示に応じた応答を生成するシステムです。本仕様におけるエージェントは、主にウェブ情報、特にWikipediaや天気情報を取得するために設計されています。

### 2. データ取得プロセス

#### 2.1 ツールのロード

エージェントは、指定されたツールを使用して情報を取得します。`load_tools`関数を用いて、必要なツール（例えば、`requests_all`など）をロードします。この際、`allow_dangerous_tools=True`オプションが設定されている場合、セキュリティリスクのあるツールも許可されます。

#### 2.2 情報の取得

取得する情報の具体例として、天気情報やWikipediaの記事があります。エージェントは、指定されたURL（日本気象協会の天気予報データのJSONファイルや、Wikipediaの日本語記事）にアクセスし、ダウンロードされたデータを解析します。

### 3. ユーザーの指示への応答

エージェントは、ユーザーからの自然言語による指示を受け取ります。例えば、「東京の天気情報を取得してください」や「スコッチウイスキーについて調べてください」といった指示があります。この過程では、以下のポイントが重要です。

#### 3.1 チャットモデルの設定

ユーザーの質問に自然な形で応答するために、`ChatOpenAI`を利用したチャットモデルを設定します。具体的には、温度を0にすることで、一貫した応答が得られるようにしています。この設定により、エージェントは同様の入力に対して一貫した回答を生成します。

#### 3.2 会話の記憶

対話型エージェントの場合、過去の会話を記憶し、ユーザーとの対話が連続的に行われるようにするため、`ConversationBufferMemory`を使用します。これにより、エージェントは以前のやり取りを参照し、より自然な応答が可能になります。

### 4. 生成されたデータの扱い

エージェントが生成したデータは、ユーザーからの指示に基づいた情報として扱われます。生成されたデータの例としては、Wikipediaからの情報や天気予報の詳細が挙げられます。これらのデータは、コンソール出力されるほか、指定された形式（テキストファイル等）で保存されることもあります。

#### 4.1 結果の出力

エージェントの処理結果は、`print(result)`でコンソールに表示されます。また、必要に応じて結果をファイル（例えば「4_agent_result1.txt」や「4_agent_result2.txt」として）に保存することもできます。これにより、後のデータ解析や再利用が可能になります。

### 5. 重要なファイルと機能

- **1_agent.py**: 主要なエージェントの初期化と実行、ツールのロード。
- **3_agent.py**: Wikipedia情報の取得と結果のファイル保存機能。
- **4_agent.py**: 対話を記憶しながら、ユーザーの指示に応じた情報取得を行うエージェントの実装。

このように、LangChainを利用したエージェント機能は、情報取得、ユーザー指示応答、データ生成・保存といった一連のプロセスを包括的に管理し、ユーザーが求める情報を効率的に取得するための柔軟なソリューションを提供します。

## 7. テストとデバッグ


このセクションでは、テスト戦略とデバッグ手法について整理し、特に処理エラーに関連する重要なポイントに焦点を当てます。

### テスト戦略

#### 1. ユニットテスト
- **EUSLISPを使用したユニットテスト**:
  - `require`文により、`unittest`ライブラリをインポートし、ユニットテストの機能を利用します。
  - `unless`構文を使用して、ユニットテストの初期化を行う条件を指定し、必要に応じて`init-unit-test`を呼び出します。

#### 2. テストの設定
- **初期化手順**:
  - `init-test`関数において、必要なオブジェクトが適切に初期化されることを確認し、その後、`*daisya*`や`*dxl-armed-turtlebot*`といったインスタンスを生成し、管理対象に登録します。
- **テスト関数の定義**:
  - `deftest`を使ってテスト関数を定義し、各テストケースで特定の機能や処理を検証します。特に、`test-maze-init`関数ではアサーションを用いて、初期化や動作の正確性を確認します。

#### 3. テスト実行
- **テストスイートの実行**:
  - `run-all-tests`関数を呼び出すことで、設定した全てのテストを実行し、結果を確認します。

### デバッグ手法

#### 1. エラーハンドリング
- 各関数において、予期しない入力や状態に対処するためのエラーハンドリングが実装されています。これにより、処理エラーが発生した際に適切なメッセージを表示し、プログラムがクラッシュすることを防ぎます。
  
#### 2. ロギング
- テスト実行中に問題が発生した際、エラーメッセージや状況を記録するログ機能が重要です。これにより、デバッグの際に問題の発生源を特定しやすくなります。

#### 3. 逐次実行
- 特定の処理の問題を特定するために、手動または自動方式で逐次実行し、各ステップでのデータ状況を確認します。この手法は、特に複雑な処理の流れを追う時に効果的です。

### 処理エラー
- プログラムによっては、特定の条件や入力に対して処理エラーが発生することがあります。これらの処理エラーは、以下のような状況で発生することが考えられます:
  - 無効なデータ形式や不正なパラメータに対する処理。
  - 外部リソース（ファイルやデータベース）へのアクセスの失敗。
  - 初期化されていない、または適切に設定されていないオブジェクトに対する操作。
  
これらの処理エラーを管理するためには、適切なエラーハンドリングメカニズムの実装が不可欠です。また、テスト段階での徹底的な項目確認が重要です。

#### まとめ
テスト戦略とデバッグ手法のしっかりとした計画と実行は、プログラムの信頼性を高め、最終的な品質を向上させます。特にエラー処理は、使用者にとっても重要な部分であるため、充実したコメントやドキュメンテーションを通じて理解を促進しなければなりません。

## 8. 今後の展望


### 機能追加計画
このプロジェクトでは、今後のバージョンで以下の機能追加を予定しています。

1. **データ可視化機能の強化**:
   - データ分析の結果を視覚的に表現するための新しいグラフライブラリとの統合を次期リリースで進め、ユーザーが結果を理解しやすくする機能を追加します。

2. **自動化されたデータフロー**:
   - データの入力から出力までを自動化するフローの開発を計画しています。これにより、ユーザーは手動での操作を最小化し、効率的にタスクを完了することが可能になります。

3. **多言語サポート**:
   - ユーザーの国際化を考慮し、プロンプトや出力を複数の言語で提供する機能を検討しています。

### 改善計画
既存機能の改善についても注力しており、以下の箇所が改善対象となります。

1. **コードのドキュメンテーション**:
   - 特に、関数定義や処理フローに対するコメントを充実させ、ユーザーや将来的な開発者が理解しやすいコードベースを目指します。

2. **エラーハンドリングの向上**:
   - 現在のエラーハンドリング機能を見直し、ユーザーに対するエラーメッセージの明確化と原因追及が容易な仕組みを整備します。

3. **パフォーマンスの最適化**:
   - データ処理の効率を向上させるため、ボトルネックとなる箇所の分析を行い、最適化を実施します。

### 進捗管理方法
プロジェクトの進捗管理には以下の方法を用います。

1. **アジャイル開発の導入**:
   - スプリントレビューやデイリースタンドアップミーティングを実施し、チーム全体の進捗を可視化し共有します。これにより、変更や問題が発生した際にも迅速に対応できます。

2. **タスク管理ツールの活用**:
   - JIRAやTrelloといったタスク管理ツールを使用し、各機能や改善点をタスクとして整理し、優先順位を付けて進捗を管理します。

### 開発方針
開発方針には以下のポイントが含まれます。

1. **オープンソースの精神**:
   - プロジェクトはオープンソースとして運営し、外部からの貢献を奨励します。これにより、コミュニティのフィードバックを受け入れ、品質の向上に繋げます。

2. **ユーザー中心のアプローチ**:
   - ユーザーからのフィードバックを重視し、ユーザーのニーズに基づいて機能を開発・改善します。定期的なアンケートやユーザーレビューを通じて意見を収集します。

3. **持続可能な成長を目指す**:
   - プロジェクトの長期的な成長を見据え、機能追加や改善のバランスを考慮し、資源や時間を適切に見積もった計画を立てます。

このような計画を通じて、プロジェクトが持続的に進化し、ユーザーや開発者にとって価値のあるツールであり続けることを目指します。

